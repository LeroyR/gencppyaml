@###############################################
@#
@# ROS message source code generation for C++/yaml-cpp
@#
@# EmPy template for generating <msg>.h files
@#
@###############################################
@# Start of Template
@#
@# Context:
@#  - file_name_in (String) Source file
@#  - spec (msggen.MsgSpec) Parsed specification of the .msg file
@#  - md5sum (String) MD5Sum of the .msg specification
@###############################################
// Generated by genyamlcpp from file @(spec.package)/@(spec.short_name).msg
// DO NOT EDIT!

@{
import genmsg.msgs
import genyamlcpp
import os
}@

#pragma once

@##############################
@# Generic Includes
@##############################

#include <yaml-cpp/yaml.h>

@##############################
@# Include cpp message header
@##############################

#include <@(spec.package)/@(spec.short_name).h>

@##############################
@# Includes for dependencies
@##############################
@{
for field in spec.parsed_fields():
  if (not field.is_builtin):
    (package, name) = genmsg.names.package_resource_name(field.base_type)
    package = package or spec.package # convert '' to package
    print('#include <%s/yaml/%s.h>'%(package, name))
  elif(field.base_type == "duration"):
    print('#include <ros/yaml/duration.h>')
  elif(field.base_type == "time"):
    print('#include <ros/yaml/time.h>')
}@


namespace YAML
{
template <>
struct convert<@(spec.package)::@(spec.short_name)>
{
  static Node encode(const @(spec.package)::@(spec.short_name)& msg)
  {
    Node node;
@{
for field in spec.parsed_fields():
  cpp_type = genyamlcpp.msg_type_to_cpp(field.type)
  if (field.is_array):
    print('    for (auto %s_item : msg.%s) {'%(field.name,field.name))
    print('      node["%s"].push_back(%s_item);'%(field.name,field.name))
    print("    }")
  else:
    if (field.base_type == "bool"):
      print('    node["%s"] = (bool) msg.%s;'%(field.name, field.name))
    else:
      print('    node["%s"] = msg.%s;'%(field.name, field.name))
}@
    return node;
  }

  static bool decode(const Node& node, @(spec.package)::@(spec.short_name)& msg)
  {
    if (node.Type() == YAML::NodeType::Null) return true;
@{
for field in spec.parsed_fields():
  cpp_type = genyamlcpp.msg_type_to_cpp(field.type)
  if (field.is_array):
    print('    if (node.Type() == YAML::NodeType::Map && node["%s"] && node["%s"].IsSequence()) {'%(field.name,field.name))
    if(field.array_len is not None):
      print('      for(unsigned int i = 0; i < node["%s"].size(); ++i) {'%(field.name))
      print('        msg.%s[i] = node["%s"][i].as<%s>();'%(field.name,field.name,cpp_type))
    else:
      print('      for(unsigned int i = 0; i < node["%s"].size(); ++i) {'%(field.name))
      print('        msg.%s.push_back(node["%s"][i].as<%s>());'%(field.name,field.name,cpp_type))
    print("      }")
    print("    }")
  else:
    print('    if (node.Type() == YAML::NodeType::Map && node["%s"]) {'%(field.name))
    print('      msg.%s = node["%s"].as<%s>();'%(field.name, field.name, cpp_type))
    print('    } else {')
    print('      //leave field empty')
    print('    }')
}@
    return true;
  }
};

} // namespace YAML
